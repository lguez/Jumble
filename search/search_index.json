{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"What is it? Jumble is a library of various utilities in Fortran 2003, basic mathematical constants and basic procedures for numerical tasks. Author or collector: Lionel GUEZ","title":"Home"},{"location":"#what-is-it","text":"Jumble is a library of various utilities in Fortran 2003, basic mathematical constants and basic procedures for numerical tasks. Author or collector: Lionel GUEZ","title":"What is it?"},{"location":"NR_util/","text":"Origin of NR_util The NR_util part of Jumble originates from the \"utility routines\" of Numerical Recipes in Fortran 90 (Press et al., 1996, Cambridge University Press, appendix C1), version 2.10a , contained in files nrtype.f90 and nrutil.f90 . These files of Numerical Recipes were put in the public domain by Press et al. Why not just use the original files of Press et al.? The motivations were: better treatment of kind attribute ; more comfortable and secure interface taking advantage of the evolution of the Fortran language. (Press et al. have not released any new version of their code since their version 2.10a, in 2002.) Difference with the original code of Numerical Recipes The names of the procedures in sub-directory NR_util are the same as the original ones. The content of some procedures is changed but no public interface has been added. As mentioned above, one of the differences between the original routines and NR_util is the treatment of kind attributes. Whereas Numerical Recipes used three explicit integer kinds (i4b, i2b and i1b), two explicit real kinds (sp and dp), two explicit complex kinds (spc and dpc) and one explicit logical kind (lgt), NR_util only uses one explicit real kind (which is named wp) (used also for complex variables). Some procedures of NR_util are coded with this parameterized real kind. Other procedures (those which are simple enough) are duplicated for default real kind and double precision, with a generic interface to these two versions. You can see below the rationale for this modification if you are interested. Other differences between the original routines and NR_util: comments in source code; one file for each procedure not part of a generic procedure; one file for each generic procedure, with all its specific procedures; module variables distributed in relevant module files (e. g. npar_arth ) or made local ( NPAR_CUMPROD ); removed stat arguments to allocate ; removed tabulation characters (they are not allowed by Fortran standard); replaced stop character string by print and stop 1. Still other differences between the original routines and NR_util, on details, made before git log: renamed some specific procedures associated to the generic swap; made uniform the interfaces of specific procedures for swap and made mask an optional argument, so the interface name masked_swap no longer exists; added specific cumsum_d to generic cumsum; corrected repeated call to size in get_diag ; faster algorithm in ifirstloc and added optional argument my_lbound ; simplified imaxloc; simplified iminloc and added specific procedure iminloc_d ; bug fix in scatter_max , intent must be inout, not out. Rationale for treatment of kind attribute The treatment of kind attributes is different in NR_util than in the original \"utility routines\" of Numerical Recipes. The procedures in NR_util do not essentially require a large precision. For example, they do not require by themselves real double precision. But, if a procedure of NR_util has a real argument, we want to allow a user to call this procedure with an actual argument of all possible real kinds (depending on the needs of the calling program). It does not make sense to define several named constants for several real kinds (sp and dp in the original routines): either you duplicate the routines or you parameterize them with a single named constant. See the page on Managing kind parameters for numeric types in Fortran 2003 . For integer data objects, we have removed the i4b kind parameterization. This parameterization did not make any sense for the routines of NR_util (it was used needlessly for local loop counters, for example). All the integer data objects of NR_util are of default integer kind.","title":"Origin of NR_util"},{"location":"NR_util/#origin-of-nr_util","text":"The NR_util part of Jumble originates from the \"utility routines\" of Numerical Recipes in Fortran 90 (Press et al., 1996, Cambridge University Press, appendix C1), version 2.10a , contained in files nrtype.f90 and nrutil.f90 . These files of Numerical Recipes were put in the public domain by Press et al. Why not just use the original files of Press et al.? The motivations were: better treatment of kind attribute ; more comfortable and secure interface taking advantage of the evolution of the Fortran language. (Press et al. have not released any new version of their code since their version 2.10a, in 2002.)","title":"Origin of NR_util"},{"location":"NR_util/#difference-with-the-original-code-of-numerical-recipes","text":"The names of the procedures in sub-directory NR_util are the same as the original ones. The content of some procedures is changed but no public interface has been added. As mentioned above, one of the differences between the original routines and NR_util is the treatment of kind attributes. Whereas Numerical Recipes used three explicit integer kinds (i4b, i2b and i1b), two explicit real kinds (sp and dp), two explicit complex kinds (spc and dpc) and one explicit logical kind (lgt), NR_util only uses one explicit real kind (which is named wp) (used also for complex variables). Some procedures of NR_util are coded with this parameterized real kind. Other procedures (those which are simple enough) are duplicated for default real kind and double precision, with a generic interface to these two versions. You can see below the rationale for this modification if you are interested. Other differences between the original routines and NR_util: comments in source code; one file for each procedure not part of a generic procedure; one file for each generic procedure, with all its specific procedures; module variables distributed in relevant module files (e. g. npar_arth ) or made local ( NPAR_CUMPROD ); removed stat arguments to allocate ; removed tabulation characters (they are not allowed by Fortran standard); replaced stop character string by print and stop 1. Still other differences between the original routines and NR_util, on details, made before git log: renamed some specific procedures associated to the generic swap; made uniform the interfaces of specific procedures for swap and made mask an optional argument, so the interface name masked_swap no longer exists; added specific cumsum_d to generic cumsum; corrected repeated call to size in get_diag ; faster algorithm in ifirstloc and added optional argument my_lbound ; simplified imaxloc; simplified iminloc and added specific procedure iminloc_d ; bug fix in scatter_max , intent must be inout, not out.","title":"Difference with the original code of Numerical Recipes"},{"location":"NR_util/#rationale-for-treatment-of-kind-attribute","text":"The treatment of kind attributes is different in NR_util than in the original \"utility routines\" of Numerical Recipes. The procedures in NR_util do not essentially require a large precision. For example, they do not require by themselves real double precision. But, if a procedure of NR_util has a real argument, we want to allow a user to call this procedure with an actual argument of all possible real kinds (depending on the needs of the calling program). It does not make sense to define several named constants for several real kinds (sp and dp in the original routines): either you duplicate the routines or you parameterize them with a single named constant. See the page on Managing kind parameters for numeric types in Fortran 2003 . For integer data objects, we have removed the i4b kind parameterization. This parameterization did not make any sense for the routines of NR_util (it was used needlessly for local loop counters, for example). All the integer data objects of NR_util are of default integer kind.","title":"Rationale for treatment of kind attribute"},{"location":"detailed_content/","text":"Detailed content of Jumble Mathematical constants defined in Jumble: \u03c0, \u03c0 / 2, 2 \u03c0, \u221a2, Euler constant, \u03c0 / 180, 180 / \u03c0. See module nrtype . Find below a list of procedures with a short description for each and a link to the source code. From NR_util array_copy : Copies to a destination array dest the one-dimensional array src, or as much of src as will fit in dest. arth : Arithmetic progression. assert_eq : Exit with error message if integer arguments not all equal. assert : Exit with error message if any assertion is false. cumprod : Cumulative product on an array, with optional multiplicative seed. cumsum : Cumulative sums of one-dimensional array, with optional seed value. diagadd : Adds vector to diagonal of a matrix. diagmult : Multiplies vector into diagonal of a matrix. geop : Return a geometrical progression as an array. get_diag : Gets diagonal of a matrix. ifirstloc : Location of first true value in a logical array, returned as an integer. lower_triangle : Returns a lower triangular logical mask. nrerror : Exit with error message. outerand : Returns the outer logical and of two vectors. outerdiff : Returns a matrix that is the outer difference of two vectors. outerdiv : Returns a matrix that is the outer quotient of two vectors. outerprod : Returns the outer product of two vectors. outersum : Returns the outer sum of two vectors. poly : Evaluate a polynomial P(x) for one or more values x, with optional mask. poly_term : Returns partial cumulants of a polynomial, equivalent to synthetic division. put_diag : Sets diagonal of a matrix. reallocate : Reallocate pointer to new size, preserving its contents. scatter_add : Scatter-adds source vector to specified components of destination vector. scatter_max : Scatter-max source vector to specified components of destination vector. swap : Swap elements of two input arguments corresponding to input mask. unit_matrix : Sets matrix to be a unit matrix. upper_triangle : Returns an upper triangular logical mask. vabs : Length of a vector in L2 norm. zroots_unity : Returns nn consecutive powers of the nth root of unity. Input-output compare : Prints maximum absolute difference and maximum relative difference between two real arrays, with the location of this maximum. count_lines : Counts the number of lines in an external file. csvread : Reads numeric values from a CSV (comma-separated values) file. get_command_arg_dyn : Wrapper for get_command_argument with automatic allocation of the character argument. new_unit : Provides a licit and not already opened external file unit. pr_matrix : Pretty prints a real matrix. read_column : Reads a column of values in an external file, given by its file name. read_opcol : Reads a column of values in an external file, given by its logical unit. readline : Reads a line from an external file. Linear algebra in 2 dimensions on real numbers determin : Computes the determinant of a (2, 2) real matrix. eigval : Computes real eigenvalues of a (2, 2) real matrix. eigvect : Computes the matrix of eigenvectors of a (2, 2) real matrix. inv_mat : Computes the inverse of a (2, 2) real matrix. set2lin : Solves a set of 2 linear equations. Other argwhere : Finds the indices of true elements. avg_mag : Computes average magnitude of an array: average of decimal log of absolute value, where not 0. averge : Computes the arithmetic average of arithmetic and geometric averages. averge : Computes the arithmetic average of arithmetic and geometric averages. count_substrings : Counts the number of occurrences of a substring in a string. divisors : Returns all the divisors of a given integer. ediff1d : Computes the differences between consecutive elements of an array. greg2jd : Converts a date on the Gregorian or Julian calendar to a Julian date. Adapted from David G. Simpson. iso_varying_string : Varying-length strings, conformant to ISO Fortran 95 extension, by Rich Townsend. mean : Computes the mean, taking missing values into account. opt_merge : Merges an optional parameter and a default value. pack_indices : Given a two-dimensional integer array and a list of array values to be excluded, returns the indices of the elements not excluded point : Returns the element of an array, given the vector of its indices. quadrat : Computes the real roots of a quadratic equation with real coefficients. rectsph : Converts rectangular coordinates to spherical coordinates. sphbase : Returns the matrix of the spherical base: (radial vector, colatitude vector, azimuthal vector) in the cartesian vector base: (x, y, z). sphrect : Converts spherical coordinates to rectangular coordinates. squeeze : Replaces repeated successive occurrences of a character in a string by a single occurrence of that character. uniq : Reports or omits repeated elements of an array.","title":"Detailed content of Jumble"},{"location":"detailed_content/#detailed-content-of-jumble","text":"Mathematical constants defined in Jumble: \u03c0, \u03c0 / 2, 2 \u03c0, \u221a2, Euler constant, \u03c0 / 180, 180 / \u03c0. See module nrtype . Find below a list of procedures with a short description for each and a link to the source code.","title":"Detailed content of Jumble"},{"location":"detailed_content/#from-nr_util","text":"array_copy : Copies to a destination array dest the one-dimensional array src, or as much of src as will fit in dest. arth : Arithmetic progression. assert_eq : Exit with error message if integer arguments not all equal. assert : Exit with error message if any assertion is false. cumprod : Cumulative product on an array, with optional multiplicative seed. cumsum : Cumulative sums of one-dimensional array, with optional seed value. diagadd : Adds vector to diagonal of a matrix. diagmult : Multiplies vector into diagonal of a matrix. geop : Return a geometrical progression as an array. get_diag : Gets diagonal of a matrix. ifirstloc : Location of first true value in a logical array, returned as an integer. lower_triangle : Returns a lower triangular logical mask. nrerror : Exit with error message. outerand : Returns the outer logical and of two vectors. outerdiff : Returns a matrix that is the outer difference of two vectors. outerdiv : Returns a matrix that is the outer quotient of two vectors. outerprod : Returns the outer product of two vectors. outersum : Returns the outer sum of two vectors. poly : Evaluate a polynomial P(x) for one or more values x, with optional mask. poly_term : Returns partial cumulants of a polynomial, equivalent to synthetic division. put_diag : Sets diagonal of a matrix. reallocate : Reallocate pointer to new size, preserving its contents. scatter_add : Scatter-adds source vector to specified components of destination vector. scatter_max : Scatter-max source vector to specified components of destination vector. swap : Swap elements of two input arguments corresponding to input mask. unit_matrix : Sets matrix to be a unit matrix. upper_triangle : Returns an upper triangular logical mask. vabs : Length of a vector in L2 norm. zroots_unity : Returns nn consecutive powers of the nth root of unity.","title":"From NR_util"},{"location":"detailed_content/#input-output","text":"compare : Prints maximum absolute difference and maximum relative difference between two real arrays, with the location of this maximum. count_lines : Counts the number of lines in an external file. csvread : Reads numeric values from a CSV (comma-separated values) file. get_command_arg_dyn : Wrapper for get_command_argument with automatic allocation of the character argument. new_unit : Provides a licit and not already opened external file unit. pr_matrix : Pretty prints a real matrix. read_column : Reads a column of values in an external file, given by its file name. read_opcol : Reads a column of values in an external file, given by its logical unit. readline : Reads a line from an external file.","title":"Input-output"},{"location":"detailed_content/#linear-algebra-in-2-dimensions-on-real-numbers","text":"determin : Computes the determinant of a (2, 2) real matrix. eigval : Computes real eigenvalues of a (2, 2) real matrix. eigvect : Computes the matrix of eigenvectors of a (2, 2) real matrix. inv_mat : Computes the inverse of a (2, 2) real matrix. set2lin : Solves a set of 2 linear equations.","title":"Linear algebra in 2 dimensions on real numbers"},{"location":"detailed_content/#other","text":"argwhere : Finds the indices of true elements. avg_mag : Computes average magnitude of an array: average of decimal log of absolute value, where not 0. averge : Computes the arithmetic average of arithmetic and geometric averages. averge : Computes the arithmetic average of arithmetic and geometric averages. count_substrings : Counts the number of occurrences of a substring in a string. divisors : Returns all the divisors of a given integer. ediff1d : Computes the differences between consecutive elements of an array. greg2jd : Converts a date on the Gregorian or Julian calendar to a Julian date. Adapted from David G. Simpson. iso_varying_string : Varying-length strings, conformant to ISO Fortran 95 extension, by Rich Townsend. mean : Computes the mean, taking missing values into account. opt_merge : Merges an optional parameter and a default value. pack_indices : Given a two-dimensional integer array and a list of array values to be excluded, returns the indices of the elements not excluded point : Returns the element of an array, given the vector of its indices. quadrat : Computes the real roots of a quadratic equation with real coefficients. rectsph : Converts rectangular coordinates to spherical coordinates. sphbase : Returns the matrix of the spherical base: (radial vector, colatitude vector, azimuthal vector) in the cartesian vector base: (x, y, z). sphrect : Converts spherical coordinates to rectangular coordinates. squeeze : Replaces repeated successive occurrences of a character in a string by a single occurrence of that character. uniq : Reports or omits repeated elements of an array.","title":"Other"},{"location":"installation/","text":"Installation Dependencies CMake (version \u2265 3.16) 1 . A Fortran compiler. Instructions Get Jumble from Github . The directory you get could be called Jumble or Jumble-master (depending on whether you cloned or downloaded a ZIP file). Create a build subdirectory in the directory you have just downloaded. For example: cd ~/Downloads/Jumble-master mkdir build cd build Decide in which directory you want to install Jumble after compilation and type the command below with your choice after -DCMAKE_INSTALL_PREFIX= (enter an absolute path). For example: cmake .. -DCMAKE_INSTALL_PREFIX=~/.local Type: make install You do not need to keep the downloaded directory (nor the build directory) after installation. Advanced instructions You can choose any name and any location for the build directory. You have to refer to the source directory when you run cmake from the build directory: mkdir /wherever/any/name cd /wherever/any/name cmake /where/I/downloaded/Jumble -DCMAKE_INSTALL_PREFIX=~/.local Optionally, you can change the precision for real numbers in procedures zroots_unity , outersum , cumprod , outerdiv and vabs . By default, the precision for real numbers in Jumble is set to be the default kind of the real type of the Fortran compiler you will use. You can change the value for the procedures listed above to any real kind you want. For example: cmake .. -DJumble_CPP_WP='kind(0d0)' or you could choose selected_real_kind(10) for example, etc. On Mac OS, after downloading the application from the CMake web site, run it, then click on \"How to Install For Command Line Use\" in the Tools menu. \u21a9","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#dependencies","text":"CMake (version \u2265 3.16) 1 . A Fortran compiler.","title":"Dependencies"},{"location":"installation/#instructions","text":"Get Jumble from Github . The directory you get could be called Jumble or Jumble-master (depending on whether you cloned or downloaded a ZIP file). Create a build subdirectory in the directory you have just downloaded. For example: cd ~/Downloads/Jumble-master mkdir build cd build Decide in which directory you want to install Jumble after compilation and type the command below with your choice after -DCMAKE_INSTALL_PREFIX= (enter an absolute path). For example: cmake .. -DCMAKE_INSTALL_PREFIX=~/.local Type: make install You do not need to keep the downloaded directory (nor the build directory) after installation.","title":"Instructions"},{"location":"installation/#advanced-instructions","text":"You can choose any name and any location for the build directory. You have to refer to the source directory when you run cmake from the build directory: mkdir /wherever/any/name cd /wherever/any/name cmake /where/I/downloaded/Jumble -DCMAKE_INSTALL_PREFIX=~/.local Optionally, you can change the precision for real numbers in procedures zroots_unity , outersum , cumprod , outerdiv and vabs . By default, the precision for real numbers in Jumble is set to be the default kind of the real type of the Fortran compiler you will use. You can change the value for the procedures listed above to any real kind you want. For example: cmake .. -DJumble_CPP_WP='kind(0d0)' or you could choose selected_real_kind(10) for example, etc. On Mac OS, after downloading the application from the CMake web site, run it, then click on \"How to Install For Command Line Use\" in the Tools menu. \u21a9","title":"Advanced instructions"},{"location":"usage/","text":"Usage In the source code of the consumer program The name of the module that you must use in your Fortran program is jumble . For example: use jumble, only: new_unit Building the consumer program with CMake If your program using Jumble is built with CMake, then add the following lines to the file CMakeLists.txt for your program: find_package(Jumble) target_link_libraries(my_program PRIVATE Jumble::jumble) Building the consumer program without CMake If you do not build the consumer program with CMake, take into account that your program will require jumble.mod (and possibly other .mod files produced by compilation of Jumble) at compile time and libjumble.a at link time. For most compilers, the options you will need to add are: -I$jumble_install_dir/include at compile time and: -L$jumble_install_dir/lib -ljumble at link time, where $jumble_install_dir is the name of the directory where you installed Jumble (the one you specified after -DCMAKE_INSTALL_PREFIX= ).","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#in-the-source-code-of-the-consumer-program","text":"The name of the module that you must use in your Fortran program is jumble . For example: use jumble, only: new_unit","title":"In the source code of the consumer program"},{"location":"usage/#building-the-consumer-program-with-cmake","text":"If your program using Jumble is built with CMake, then add the following lines to the file CMakeLists.txt for your program: find_package(Jumble) target_link_libraries(my_program PRIVATE Jumble::jumble)","title":"Building the consumer program with CMake"},{"location":"usage/#building-the-consumer-program-without-cmake","text":"If you do not build the consumer program with CMake, take into account that your program will require jumble.mod (and possibly other .mod files produced by compilation of Jumble) at compile time and libjumble.a at link time. For most compilers, the options you will need to add are: -I$jumble_install_dir/include at compile time and: -L$jumble_install_dir/lib -ljumble at link time, where $jumble_install_dir is the name of the directory where you installed Jumble (the one you specified after -DCMAKE_INSTALL_PREFIX= ).","title":"Building the consumer program without CMake"}]}